---
phase: 04-payment-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/db/schema/payments.ts
  - backend/src/db/schema/subscriptions.ts
  - backend/src/db/schema/promo-codes.ts
  - backend/src/db/schema/referrals.ts
  - backend/src/db/schema/cohorts.ts
  - backend/src/db/schema/index.ts
  - backend/drizzle/0003_*.sql
autonomous: true

must_haves:
  truths:
    - "Payment records can be stored with Midtrans transaction IDs"
    - "Subscription records track user membership periods"
    - "Promo codes can be defined with discounts and expiry dates"
    - "Referral codes are linked to member accounts"
    - "Cohorts have a price field for workshop payments"
  artifacts:
    - path: "backend/src/db/schema/payments.ts"
      provides: "Payment transaction records with Midtrans IDs"
      exports: ["payments"]
    - path: "backend/src/db/schema/subscriptions.ts"
      provides: "Subscription periods and status tracking"
      exports: ["subscriptions"]
    - path: "backend/src/db/schema/promo-codes.ts"
      provides: "Promo code definitions with discount/expiry"
      exports: ["promoCodes"]
    - path: "backend/src/db/schema/referrals.ts"
      provides: "Referral codes and usage tracking"
      exports: ["referrals", "referralUsages"]
  key_links:
    - from: "backend/src/db/schema/payments.ts"
      to: "users table"
      via: "userId foreign key"
      pattern: "references.*users"
    - from: "backend/src/db/schema/payments.ts"
      to: "cohorts table"
      via: "workshopId foreign key (cohort serves as workshop)"
      pattern: "workshopId.*integer"
    - from: "backend/src/db/schema/referrals.ts"
      to: "users table"
      via: "userId foreign key for referrer"
      pattern: "references.*users"
---

<objective>
Create database schemas for payment system: payments, subscriptions, promo codes, and referrals

Purpose: Establish the data layer for the entire payment integration phase. All subsequent payment operations depend on these schemas.
Output: Four new schema files and generated migration ready for database application
</objective>

<execution_context>
@/Users/dio/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-payment-integration/04-RESEARCH.md

Existing patterns to follow:
@backend/src/db/schema/users.ts (schema pattern with timestamps)
@backend/src/db/schema/index.ts (barrel export pattern)
@backend/drizzle.config.ts (schema file registration)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create payment and subscription schemas</name>
  <files>
    backend/src/db/schema/payments.ts
    backend/src/db/schema/subscriptions.ts
  </files>
  <action>
Create payment transaction and subscription schemas following existing patterns:

**payments.ts:**
```typescript
import { pgTable, integer, varchar, timestamp, text, pgEnum } from 'drizzle-orm/pg-core'
import { users } from './users.js'

export const paymentStatusEnum = pgEnum('payment_status', [
  'pending', 'settlement', 'capture', 'deny', 'cancel', 'expire', 'refund'
])

export const paymentTypeEnum = pgEnum('payment_type', [
  'subscription', 'workshop'
])

export const payments = pgTable('payments', {
  id: integer('id').primaryKey().generatedAlwaysAsIdentity(),
  userId: integer('user_id').notNull().references(() => users.id),

  // Midtrans identifiers (unique for idempotency)
  midtransOrderId: varchar('midtrans_order_id', { length: 100 }).notNull().unique(),
  midtransTransactionId: varchar('midtrans_transaction_id', { length: 100 }).unique(),

  // Payment details
  type: paymentTypeEnum('type').notNull(),
  status: paymentStatusEnum('status').notNull().default('pending'),
  amount: integer('amount').notNull(), // In IDR (smallest unit)

  // Optional references (workshopId references cohorts.id - cohorts serve as "workshops")
  workshopId: integer('workshop_id'), // If type = 'workshop' (references cohorts.id)
  promoCodeId: integer('promo_code_id'), // If promo applied
  referralId: integer('referral_id'), // If referral code used

  // Midtrans response data
  paymentMethod: varchar('payment_method', { length: 50 }),
  rawResponse: text('raw_response'), // JSON string of full webhook data

  createdAt: timestamp('created_at', { mode: 'date' }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { mode: 'date' }).defaultNow().notNull(),
  paidAt: timestamp('paid_at', { mode: 'date' }),
})
```

**subscriptions.ts:**
```typescript
import { pgTable, integer, varchar, timestamp, pgEnum } from 'drizzle-orm/pg-core'
import { users } from './users.js'

export const subscriptionStatusEnum = pgEnum('subscription_status', [
  'active', 'expired', 'cancelled'
])

export const subscriptions = pgTable('subscriptions', {
  id: integer('id').primaryKey().generatedAlwaysAsIdentity(),
  userId: integer('user_id').notNull().references(() => users.id),

  status: subscriptionStatusEnum('status').notNull().default('active'),

  // Payment reference
  paymentId: integer('payment_id'), // Links to original payment

  // Subscription period
  startDate: timestamp('start_date', { mode: 'date' }).notNull(),
  endDate: timestamp('end_date', { mode: 'date' }).notNull(),

  createdAt: timestamp('created_at', { mode: 'date' }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { mode: 'date' }).defaultNow().notNull(),
})
```

Use `generatedAlwaysAsIdentity()` for primary keys per modern PostgreSQL best practices (from research).
  </action>
  <verify>
Run `npx tsc --noEmit` in backend directory - no errors related to payment schemas
  </verify>
  <done>
payments.ts and subscriptions.ts exist with proper types and foreign key references to users table
  </done>
</task>

<task type="auto">
  <name>Task 2: Create promo code and referral schemas</name>
  <files>
    backend/src/db/schema/promo-codes.ts
    backend/src/db/schema/referrals.ts
  </files>
  <action>
Create promo code and referral tracking schemas:

**promo-codes.ts:**
```typescript
import { pgTable, integer, varchar, timestamp, boolean } from 'drizzle-orm/pg-core'

export const promoCodes = pgTable('promo_codes', {
  id: integer('id').primaryKey().generatedAlwaysAsIdentity(),

  // Code details
  code: varchar('code', { length: 50 }).notNull().unique(), // e.g., "NEWYEAR2026"
  description: varchar('description', { length: 255 }),

  // Discount configuration
  discountPercent: integer('discount_percent').notNull(), // 0-100

  // Usage limits
  maxUses: integer('max_uses'), // null = unlimited
  currentUses: integer('current_uses').notNull().default(0),

  // Validity period
  validFrom: timestamp('valid_from', { mode: 'date' }),
  expiresAt: timestamp('expires_at', { mode: 'date' }),

  // Status
  isActive: boolean('is_active').notNull().default(true),

  createdAt: timestamp('created_at', { mode: 'date' }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { mode: 'date' }).defaultNow().notNull(),
})
```

**referrals.ts:**
```typescript
import { pgTable, integer, varchar, timestamp } from 'drizzle-orm/pg-core'
import { relations } from 'drizzle-orm'
import { users } from './users.js'

export const referrals = pgTable('referrals', {
  id: integer('id').primaryKey().generatedAlwaysAsIdentity(),
  userId: integer('user_id').notNull().references(() => users.id).unique(), // Each user has one code

  // The referral code (auto-generated on member signup)
  code: varchar('code', { length: 20 }).notNull().unique(),

  // Stats
  totalUses: integer('total_uses').notNull().default(0),
  rewardsEarned: integer('rewards_earned').notNull().default(0), // In IDR

  createdAt: timestamp('created_at', { mode: 'date' }).defaultNow().notNull(),
})

export const referralUsages = pgTable('referral_usages', {
  id: integer('id').primaryKey().generatedAlwaysAsIdentity(),
  referralId: integer('referral_id').notNull().references(() => referrals.id),
  newUserId: integer('new_user_id').notNull().references(() => users.id),
  paymentId: integer('payment_id'), // Links to the payment that triggered reward
  rewardAmount: integer('reward_amount').notNull(), // In IDR

  createdAt: timestamp('created_at', { mode: 'date' }).defaultNow().notNull(),
})

// Drizzle relations
export const referralsRelations = relations(referrals, ({ one, many }) => ({
  user: one(users, {
    fields: [referrals.userId],
    references: [users.id],
  }),
  usages: many(referralUsages),
}))

export const referralUsagesRelations = relations(referralUsages, ({ one }) => ({
  referral: one(referrals, {
    fields: [referralUsages.referralId],
    references: [referrals.id],
  }),
  newUser: one(users, {
    fields: [referralUsages.newUserId],
    references: [users.id],
  }),
}))
```
  </action>
  <verify>
Run `npx tsc --noEmit` in backend directory - no errors
  </verify>
  <done>
promo-codes.ts and referrals.ts exist with discount logic support and referral tracking with relations
  </done>
</task>

<task type="auto">
  <name>Task 3: Add price field to cohorts schema</name>
  <files>backend/src/db/schema/cohorts.ts</files>
  <action>
Update the existing cohorts schema to add a price field for workshop payments.

**Note:** The cohorts table serves as the "workshop" concept in Stockus. Cohorts are paid group sessions - when users pay for a "workshop", they are paying for a cohort. This avoids needing a separate workshops table.

Add to `backend/src/db/schema/cohorts.ts` cohorts table:
```typescript
price: integer('price'), // Price in IDR for workshop payment (null = included in subscription)
```

Add this field after `maxParticipants` and before `deletedAt`.

The price field is nullable:
- `null` = cohort is part of subscription (member-only access)
- `> 0` = cohort has a one-time purchase price (workshop model)
  </action>
  <verify>
Run `npx tsc --noEmit` in backend directory - no errors
  </verify>
  <done>
Cohorts schema has price field to support workshop payments, allowing cohorts to be used as the workshop entity
  </done>
</task>

<task type="auto">
  <name>Task 4: Export schemas and generate migration</name>
  <files>
    backend/src/db/schema/index.ts
    backend/drizzle.config.ts
  </files>
  <action>
1. Update schema barrel export in `backend/src/db/schema/index.ts`:
   Add exports for new schema files:
   ```typescript
   export * from './payments.js'
   export * from './subscriptions.js'
   export * from './promo-codes.js'
   export * from './referrals.js'
   ```

2. Update `backend/drizzle.config.ts` to include new schema files in the explicit schema array (following existing pattern that avoids barrel imports):
   Add to schema array:
   ```typescript
   './src/db/schema/payments.ts',
   './src/db/schema/subscriptions.ts',
   './src/db/schema/promo-codes.ts',
   './src/db/schema/referrals.ts',
   ```

3. Generate migration:
   ```bash
   cd backend && npm run db:generate
   ```
   This will create a migration file in `backend/drizzle/` directory.
  </action>
  <verify>
1. Run `npx tsc --noEmit` - no errors
2. Check that migration file exists in `backend/drizzle/` starting with `0003_`
3. Verify migration SQL contains CREATE TABLE for payments, subscriptions, promo_codes, referrals, referral_usages
  </verify>
  <done>
All payment schemas exported from index.ts, drizzle.config.ts updated, migration file generated with all 5 tables (payments, subscriptions, promo_codes, referrals, referral_usages) and 4 enums (payment_status, payment_type, subscription_status)
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `cd backend && npx tsc --noEmit` passes
2. Schema exports: All new schemas importable from `./db/schema/index.js`
3. Migration generated: File exists at `backend/drizzle/0003_*.sql`
4. Migration content includes:
   - CREATE TYPE payment_status
   - CREATE TYPE payment_type
   - CREATE TYPE subscription_status
   - CREATE TABLE payments
   - CREATE TABLE subscriptions
   - CREATE TABLE promo_codes
   - CREATE TABLE referrals
   - CREATE TABLE referral_usages
   - ALTER TABLE cohorts ADD COLUMN price
</verification>

<success_criteria>
- Four new schema files created and compiling
- Cohorts schema updated with price field for workshop payments
- Migration generated with all tables, enums, and cohorts alteration
- Foreign key references to users table correct
- Workshop payments can reference cohorts.id (no separate workshops table needed)
- Ready for plan 04-02 (payment service implementation)
</success_criteria>

<output>
After completion, create `.planning/phases/04-payment-integration/04-01-SUMMARY.md`
</output>
