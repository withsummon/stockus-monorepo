---
phase: 04-payment-integration
plan: 04
type: execute
wave: 2
depends_on: ["04-01", "04-02", "04-03"]
files_modified:
  - backend/src/routes/payments.ts
  - backend/src/routes/index.ts
  - backend/src/services/email.service.ts
autonomous: true

must_haves:
  truths:
    - "Authenticated user can initiate subscription payment"
    - "Authenticated user can initiate workshop payment (via cohort with price)"
    - "Promo codes can be validated before payment"
    - "Referral codes can be applied at checkout"
    - "Payment response includes Snap token for frontend"
  artifacts:
    - path: "backend/src/routes/payments.ts"
      provides: "Payment initiation endpoints"
      exports: ["paymentRoutes"]
      min_lines: 150
  key_links:
    - from: "backend/src/routes/payments.ts"
      to: "payment.service.ts"
      via: "createSubscriptionPayment, createWorkshopPayment"
      pattern: "createSubscriptionPayment|createWorkshopPayment"
    - from: "backend/src/routes/payments.ts"
      to: "promo.service.ts"
      via: "validatePromoCode, calculateDiscountedAmount"
      pattern: "validatePromoCode"
    - from: "backend/src/routes/payments.ts"
      to: "referral.service.ts"
      via: "validateReferralCode"
      pattern: "validateReferralCode"
    - from: "backend/src/routes/payments.ts"
      to: "cohorts table"
      via: "db.query.cohorts for workshop price/name"
      pattern: "db\\.query\\.cohorts"
---

<objective>
Create payment initiation routes for subscription and workshop purchases

Purpose: Allow authenticated users to start payment flows, apply discounts, and receive Snap tokens for frontend payment UI.
Output: Payment routes mounted at /payments with subscription and workshop endpoints
</objective>

<execution_context>
@/Users/dio/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-payment-integration/04-RESEARCH.md

Existing patterns to follow:
@backend/src/routes/courses.ts (route pattern with auth middleware)
@backend/src/routes/index.ts (route mounting pattern)
@backend/src/middleware/auth.ts (authMiddleware pattern)

From prior plans in this phase:
- 04-01: Payment schemas (payments table for recording, cohorts.price for workshop pricing)
- 04-02: Payment service (createSubscriptionPayment, createWorkshopPayment)
- 04-03: Promo and referral services (validatePromoCode, validateReferralCode)

Note: Workshop payments reference cohorts.id - cohorts with a price field serve as the "workshop" concept. No separate workshops table is needed.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create payment routes</name>
  <files>backend/src/routes/payments.ts</files>
  <action>
Create `backend/src/routes/payments.ts`:

```typescript
import { Hono } from 'hono'
import { zValidator } from '@hono/zod-validator'
import { z } from 'zod'
import { db } from '../db/index.js'
import { payments, users, cohorts } from '../db/schema/index.js'
import { authMiddleware, AuthEnv } from '../middleware/auth.js'
import { createSubscriptionPayment, createWorkshopPayment } from '../services/payment.service.js'
import { validatePromoCode, calculateDiscountedAmount } from '../services/promo.service.js'
import { validateReferralCode } from '../services/referral.service.js'
import { eq } from 'drizzle-orm'

// Pricing constants (in IDR)
const SUBSCRIPTION_PRICE = 2500000 // IDR 2,500,000 annual subscription

const initiateSubscriptionSchema = z.object({
  promoCode: z.string().optional(),
  referralCode: z.string().optional(),
})

const initiateWorkshopSchema = z.object({
  cohortId: z.number().int().positive(), // Workshop = cohort with price
  promoCode: z.string().optional(),
  referralCode: z.string().optional(),
})

const validatePromoSchema = z.object({
  code: z.string().min(1),
})

const paymentRoutes = new Hono<AuthEnv>()

/**
 * POST /payments/subscription
 * Initiate subscription payment
 * Returns Midtrans Snap token for frontend
 */
paymentRoutes.post(
  '/subscription',
  authMiddleware,
  zValidator('json', initiateSubscriptionSchema),
  async (c) => {
    const userId = c.get('userId')
    const body = c.req.valid('json')

    // Get user details
    const user = await db.query.users.findFirst({
      where: eq(users.id, userId),
    })

    if (!user) {
      return c.json({ error: 'User not found' }, 404)
    }

    // Check if user already has active subscription
    if (user.tier === 'member') {
      return c.json({
        error: 'Already subscribed',
        message: 'You already have an active subscription'
      }, 400)
    }

    // Calculate final amount with discounts
    let finalAmount = SUBSCRIPTION_PRICE
    let promoCodeId: number | undefined
    let referralId: number | undefined

    // Validate and apply promo code
    if (body.promoCode) {
      const promoResult = await validatePromoCode(body.promoCode)
      if (!promoResult.success) {
        return c.json({ error: promoResult.error }, 400)
      }
      promoCodeId = promoResult.promoCodeId
      finalAmount = calculateDiscountedAmount(finalAmount, promoResult.discountPercent!)
    }

    // Validate referral code
    if (body.referralCode) {
      const referralResult = await validateReferralCode(body.referralCode)
      if (!referralResult.success) {
        return c.json({ error: referralResult.error }, 400)
      }
      // Cannot use own referral code
      if (referralResult.referrerId === userId) {
        return c.json({ error: 'Cannot use your own referral code' }, 400)
      }
      referralId = referralResult.referralId
    }

    // Create Midtrans Snap transaction
    const paymentResult = await createSubscriptionPayment({
      userId,
      userEmail: user.email,
      userName: user.name,
      amount: finalAmount,
      promoCodeId,
      referralId,
    })

    if (!paymentResult.success) {
      return c.json({ error: paymentResult.error }, 500)
    }

    // Create pending payment record
    await db.insert(payments).values({
      userId,
      midtransOrderId: paymentResult.orderId!,
      type: 'subscription',
      status: 'pending',
      amount: finalAmount,
      promoCodeId,
      referralId,
    })

    return c.json({
      token: paymentResult.token,
      redirectUrl: paymentResult.redirectUrl,
      orderId: paymentResult.orderId,
      amount: finalAmount,
      originalAmount: SUBSCRIPTION_PRICE,
      discount: SUBSCRIPTION_PRICE - finalAmount,
    })
  }
)

/**
 * POST /payments/workshop
 * Initiate workshop payment (workshop = cohort with price)
 * Returns Midtrans Snap token for frontend
 */
paymentRoutes.post(
  '/workshop',
  authMiddleware,
  zValidator('json', initiateWorkshopSchema),
  async (c) => {
    const userId = c.get('userId')
    const body = c.req.valid('json')

    // Get user details
    const user = await db.query.users.findFirst({
      where: eq(users.id, userId),
    })

    if (!user) {
      return c.json({ error: 'User not found' }, 404)
    }

    // Fetch cohort (workshop) from database
    // Note: In Stockus, cohorts with a price field serve as "workshops"
    const cohort = await db.query.cohorts.findFirst({
      where: eq(cohorts.id, body.cohortId),
      with: {
        course: true,
      },
    })

    if (!cohort) {
      return c.json({ error: 'Workshop not found' }, 404)
    }

    if (!cohort.price) {
      return c.json({
        error: 'This cohort is not a paid workshop',
        message: 'Cohorts without a price are part of the subscription'
      }, 400)
    }

    if (cohort.status !== 'open') {
      return c.json({ error: 'Workshop enrollment is not open' }, 400)
    }

    const workshopPrice = cohort.price
    const workshopName = cohort.name || `${cohort.course.title} - Cohort`

    let finalAmount = workshopPrice
    let promoCodeId: number | undefined
    let referralId: number | undefined

    // Validate and apply promo code
    if (body.promoCode) {
      const promoResult = await validatePromoCode(body.promoCode)
      if (!promoResult.success) {
        return c.json({ error: promoResult.error }, 400)
      }
      promoCodeId = promoResult.promoCodeId
      finalAmount = calculateDiscountedAmount(finalAmount, promoResult.discountPercent!)
    }

    // Validate referral code
    if (body.referralCode) {
      const referralResult = await validateReferralCode(body.referralCode)
      if (!referralResult.success) {
        return c.json({ error: referralResult.error }, 400)
      }
      if (referralResult.referrerId === userId) {
        return c.json({ error: 'Cannot use your own referral code' }, 400)
      }
      referralId = referralResult.referralId
    }

    // Create Midtrans Snap transaction
    const paymentResult = await createWorkshopPayment({
      userId,
      userEmail: user.email,
      userName: user.name,
      amount: finalAmount,
      workshopId: body.cohortId, // cohortId is stored as workshopId
      workshopName,
      promoCodeId,
      referralId,
    })

    if (!paymentResult.success) {
      return c.json({ error: paymentResult.error }, 500)
    }

    // Create pending payment record
    // Note: workshopId references cohorts.id (cohorts serve as workshops)
    await db.insert(payments).values({
      userId,
      midtransOrderId: paymentResult.orderId!,
      type: 'workshop',
      status: 'pending',
      amount: finalAmount,
      workshopId: body.cohortId,
      promoCodeId,
      referralId,
    })

    return c.json({
      token: paymentResult.token,
      redirectUrl: paymentResult.redirectUrl,
      orderId: paymentResult.orderId,
      amount: finalAmount,
      originalAmount: workshopPrice,
      discount: workshopPrice - finalAmount,
    })
  }
)

/**
 * POST /payments/validate-promo
 * Validate promo code without initiating payment
 * Returns discount percentage if valid
 */
paymentRoutes.post(
  '/validate-promo',
  authMiddleware,
  zValidator('json', validatePromoSchema),
  async (c) => {
    const body = c.req.valid('json')

    const result = await validatePromoCode(body.code)

    if (!result.success) {
      return c.json({ valid: false, error: result.error }, 400)
    }

    return c.json({
      valid: true,
      discountPercent: result.discountPercent,
    })
  }
)

/**
 * GET /payments/history
 * Get user's payment history
 */
paymentRoutes.get(
  '/history',
  authMiddleware,
  async (c) => {
    const userId = c.get('userId')

    const userPayments = await db.query.payments.findMany({
      where: eq(payments.userId, userId),
      orderBy: (payments, { desc }) => [desc(payments.createdAt)],
    })

    return c.json({ payments: userPayments })
  }
)

export { paymentRoutes }
```
  </action>
  <verify>
Run `npx tsc --noEmit` - no errors
  </verify>
  <done>
paymentRoutes exports with subscription, workshop, validate-promo, and history endpoints
  </done>
</task>

<task type="auto">
  <name>Task 2: Mount payment routes and add receipt email</name>
  <files>
    backend/src/routes/index.ts
    backend/src/services/email.service.ts
  </files>
  <action>
1. Update `backend/src/routes/index.ts` to mount payment routes:

Add import:
```typescript
import { paymentRoutes } from './payments.js'
```

Add route mounting after other routes:
```typescript
// Payment routes
routes.route('/payments', paymentRoutes)
```

2. Add payment receipt email to `backend/src/services/email.service.ts`:

Add new function:
```typescript
/**
 * Send payment receipt email
 */
export async function sendPaymentReceiptEmail(
  to: string,
  userName: string,
  orderId: string,
  amount: number,
  itemName: string
): Promise<EmailResult> {
  const formattedAmount = new Intl.NumberFormat('id-ID', {
    style: 'currency',
    currency: 'IDR',
    minimumFractionDigits: 0,
  }).format(amount)

  try {
    const { data, error } = await resend.emails.send({
      from: env.EMAIL_FROM,
      to,
      subject: 'Payment Confirmation - StockUs',
      html: `
        <h2>Payment Confirmed</h2>
        <p>Hi ${userName},</p>
        <p>Thank you for your purchase! Your payment has been confirmed.</p>

        <h3>Order Details</h3>
        <table style="border-collapse: collapse; width: 100%; max-width: 400px;">
          <tr>
            <td style="padding: 8px; border-bottom: 1px solid #eee;">Order ID</td>
            <td style="padding: 8px; border-bottom: 1px solid #eee; text-align: right;">${orderId}</td>
          </tr>
          <tr>
            <td style="padding: 8px; border-bottom: 1px solid #eee;">Item</td>
            <td style="padding: 8px; border-bottom: 1px solid #eee; text-align: right;">${itemName}</td>
          </tr>
          <tr>
            <td style="padding: 8px; border-bottom: 1px solid #eee;"><strong>Total</strong></td>
            <td style="padding: 8px; border-bottom: 1px solid #eee; text-align: right;"><strong>${formattedAmount}</strong></td>
          </tr>
        </table>

        <p style="margin-top: 20px;">If you have any questions, please contact our support team.</p>
        <p>Thank you for being part of StockUs!</p>
      `,
    })

    if (error) {
      return { success: false, error: error.message }
    }

    return { success: true, messageId: data?.id }
  } catch (err) {
    return {
      success: false,
      error: err instanceof Error ? err.message : 'Unknown error'
    }
  }
}
```
  </action>
  <verify>
1. Run `npx tsc --noEmit` - no errors
2. Check routes/index.ts imports paymentRoutes
3. Check email.service.ts exports sendPaymentReceiptEmail
  </verify>
  <done>
Payment routes mounted at /payments, receipt email function added to email service
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `cd backend && npx tsc --noEmit` passes
2. Route mounting: paymentRoutes mounted at /payments in routes/index.ts
3. Endpoints available:
   - POST /payments/subscription
   - POST /payments/workshop
   - POST /payments/validate-promo
   - GET /payments/history
4. Email: sendPaymentReceiptEmail exported from email.service.ts
</verification>

<success_criteria>
- Subscription payment creates pending record and returns Snap token
- Workshop payment (via cohort with price) creates pending record and returns Snap token
- Workshop endpoint queries cohorts table for price and name (not hardcoded placeholders)
- Promo code validation returns discount percentage
- Referral code validated (cannot use own code)
- Payment history endpoint returns user's payments
- Receipt email template ready for webhook to send
</success_criteria>

<output>
After completion, create `.planning/phases/04-payment-integration/04-04-SUMMARY.md`
</output>
