---
phase: 08-admin-dashboard
plan: 04
type: execute
wave: 2
depends_on: ["08-01", "08-02"]
files_modified:
  - frontend/src/app/(admin)/admin/courses/page.tsx
  - frontend/src/app/(admin)/admin/courses/columns.tsx
  - frontend/src/app/(admin)/admin/courses/new/page.tsx
  - frontend/src/app/(admin)/admin/courses/[id]/page.tsx
  - frontend/src/lib/api/admin.ts
autonomous: true

must_haves:
  truths:
    - "Admin can view list of all courses in a table"
    - "Admin can create a new course"
    - "Admin can edit an existing course"
    - "Admin can delete a course"
  artifacts:
    - path: "frontend/src/app/(admin)/admin/courses/page.tsx"
      provides: "Course list page with data table"
      contains: "DataTable"
    - path: "frontend/src/app/(admin)/admin/courses/new/page.tsx"
      provides: "Create course form"
      contains: "useForm"
    - path: "frontend/src/app/(admin)/admin/courses/[id]/page.tsx"
      provides: "Edit course form"
      contains: "useForm"
  key_links:
    - from: "frontend/src/app/(admin)/admin/courses/page.tsx"
      to: "/courses"
      via: "API fetch"
      pattern: "fetch.*courses"
    - from: "frontend/src/app/(admin)/admin/courses/new/page.tsx"
      to: "POST /courses"
      via: "form submit"
      pattern: "method.*POST"
---

<objective>
Build course management interface with list view, create form, and edit form.

Purpose: Enables admins to manage courses (ADMN-01 requirement). Uses existing backend CRUD routes at /courses.

Output:
- Course list page with DataTable
- Create course page with form
- Edit course page with form
- Delete functionality in list actions
</objective>

<execution_context>
@/Users/dio/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-admin-dashboard/08-RESEARCH.md
@.planning/phases/08-admin-dashboard/08-01-SUMMARY.md
@.planning/phases/08-admin-dashboard/08-02-SUMMARY.md

# Backend course routes already exist:
@backend/src/routes/courses.ts
# POST / - Create course (admin only)
# PATCH /:id - Update course (admin only)
# DELETE /:id - Soft delete course (admin only)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add course API functions to admin client</name>
  <files>
    frontend/src/lib/api/admin.ts
  </files>
  <action>
Add to frontend/src/lib/api/admin.ts:

```typescript
// Course types
export interface Course {
  id: number
  title: string
  slug: string
  description: string
  content: string
  thumbnailUrl: string | null
  status: string
  isFreePreview: boolean
  createdAt: string
  updatedAt: string
  sessions?: CourseSession[]
}

export interface CourseSession {
  id: number
  courseId: number
  title: string
  description: string | null
  sessionOrder: number
  durationMinutes: number | null
  videoUrl: string | null
}

export interface CourseFormData {
  title: string
  description?: string
  content?: string
  thumbnailUrl?: string | null
  isFreePreview?: boolean
}

// Course API functions
export async function getAdminCourses() {
  // Note: Use the regular /courses endpoint which already returns all courses for authenticated users
  // Admin middleware is only needed for POST/PATCH/DELETE
  const data = await adminFetch('/courses')
  return data.courses as Course[]
}

export async function getAdminCourse(id: number) {
  const data = await adminFetch(`/courses/${id}`)
  return data.course as Course
}

export async function createCourse(data: CourseFormData) {
  return adminFetch('/courses', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  })
}

export async function updateCourse(id: number, data: Partial<CourseFormData>) {
  return adminFetch(`/courses/${id}`, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  })
}

export async function deleteCourse(id: number) {
  return adminFetch(`/courses/${id}`, {
    method: 'DELETE',
  })
}
```
  </action>
  <verify>
TypeScript compiles. Functions are exported.
  </verify>
  <done>
Course API functions added: getAdminCourses, getAdminCourse, createCourse, updateCourse, deleteCourse.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create course list page with DataTable</name>
  <files>
    frontend/src/app/(admin)/admin/courses/page.tsx
    frontend/src/app/(admin)/admin/courses/columns.tsx
  </files>
  <action>
1. Create frontend/src/app/(admin)/admin/courses/columns.tsx (client component):

```typescript
'use client'

import { ColumnDef } from '@tanstack/react-table'
import { Badge } from '@/components/ui/badge'
import { Button } from '@/components/ui/button'
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu'
import { MoreHorizontal, Pencil, Trash } from 'lucide-react'
import Link from 'next/link'
import { Course } from '@/lib/api/admin'

interface ColumnsProps {
  onDelete: (id: number) => void
}

export function getColumns({ onDelete }: ColumnsProps): ColumnDef<Course>[] {
  return [
    {
      accessorKey: 'title',
      header: 'Title',
    },
    {
      accessorKey: 'status',
      header: 'Status',
      cell: ({ row }) => (
        <Badge variant={row.original.status === 'published' ? 'default' : 'secondary'}>
          {row.original.status}
        </Badge>
      ),
    },
    {
      accessorKey: 'isFreePreview',
      header: 'Access',
      cell: ({ row }) => (
        row.original.isFreePreview ? 'Free Preview' : 'Members Only'
      ),
    },
    {
      accessorKey: 'createdAt',
      header: 'Created',
      cell: ({ row }) => new Date(row.original.createdAt).toLocaleDateString('id-ID'),
    },
    {
      id: 'actions',
      cell: ({ row }) => (
        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <Button variant="ghost" size="sm">
              <MoreHorizontal className="h-4 w-4" />
            </Button>
          </DropdownMenuTrigger>
          <DropdownMenuContent align="end">
            <DropdownMenuItem asChild>
              <Link href={`/admin/courses/${row.original.id}`}>
                <Pencil className="h-4 w-4 mr-2" />
                Edit
              </Link>
            </DropdownMenuItem>
            <DropdownMenuItem
              className="text-destructive"
              onClick={() => onDelete(row.original.id)}
            >
              <Trash className="h-4 w-4 mr-2" />
              Delete
            </DropdownMenuItem>
          </DropdownMenuContent>
        </DropdownMenu>
      ),
    },
  ]
}
```

2. Create frontend/src/app/(admin)/admin/courses/page.tsx:

Make this a client component that:
- Fetches courses on mount
- Renders DataTable with columns
- Has "Add Course" button linking to /admin/courses/new
- Handles delete with confirmation
- Refreshes list after delete

Use useEffect for initial fetch, useState for courses and loading state.
For delete, create a client-side function that calls the API and refreshes the list.
  </action>
  <verify>
Course list page renders with table. Actions dropdown works.
  </verify>
  <done>
Course list shows all courses in DataTable with Edit/Delete actions and "Add Course" button.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create course create/edit forms</name>
  <files>
    frontend/src/app/(admin)/admin/courses/new/page.tsx
    frontend/src/app/(admin)/admin/courses/[id]/page.tsx
  </files>
  <action>
1. Create frontend/src/app/(admin)/admin/courses/new/page.tsx:

```typescript
'use client'

import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'
import { useRouter } from 'next/navigation'
import { useState } from 'react'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Textarea } from '@/components/ui/textarea'
import { Checkbox } from '@/components/ui/checkbox'
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from '@/components/ui/form'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'

const courseSchema = z.object({
  title: z.string().min(3, 'Title must be at least 3 characters').max(255),
  description: z.string().optional(),
  content: z.string().optional(),
  thumbnailUrl: z.string().url().optional().nullable().or(z.literal('')),
  isFreePreview: z.boolean().default(false),
})

type CourseFormData = z.infer<typeof courseSchema>

export default function NewCoursePage() {
  const router = useRouter()
  const [isSubmitting, setIsSubmitting] = useState(false)

  const form = useForm<CourseFormData>({
    resolver: zodResolver(courseSchema),
    defaultValues: {
      title: '',
      description: '',
      content: '',
      thumbnailUrl: '',
      isFreePreview: false,
    },
  })

  async function onSubmit(data: CourseFormData) {
    setIsSubmitting(true)
    try {
      const res = await fetch('/api/admin/courses', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      })
      // OR use direct backend call with credentials

      if (res.ok) {
        router.push('/admin/courses')
      }
    } finally {
      setIsSubmitting(false)
    }
  }

  return (
    <div className="max-w-2xl">
      <h1 className="text-2xl font-bold mb-6">Create Course</h1>

      <Card>
        <CardContent className="pt-6">
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
              {/* Title, Description, Content, ThumbnailUrl, isFreePreview fields */}
              {/* Submit and Cancel buttons */}
            </form>
          </Form>
        </CardContent>
      </Card>
    </div>
  )
}
```

Form fields:
- Title (required input)
- Description (optional textarea)
- Content (optional textarea, larger)
- Thumbnail URL (optional input)
- Free Preview (checkbox)

2. Create frontend/src/app/(admin)/admin/courses/[id]/page.tsx:

Similar to new page but:
- Fetch existing course data on mount
- Pre-populate form with existing values
- Use PATCH method on submit
- Show loading state while fetching

Note: Since we need to make authenticated API calls from client components, we need a pattern:
- Option A: Create Next.js API route proxies (e.g., /api/admin/courses) that forward to backend
- Option B: Direct fetch to backend with credentials: 'include'

Use Option B for simplicity - direct fetch to backend with credentials: 'include' since CORS is configured.

API_URL from environment won't be available client-side, so use relative URL or hardcode for now.
Better approach: Create a client-side API helper that uses the browser's fetch with credentials.

Create frontend/src/lib/api/admin-client.ts for client-side API calls:
```typescript
const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000'

export async function adminClientFetch(path: string, options: RequestInit = {}) {
  const res = await fetch(`${API_URL}${path}`, {
    ...options,
    credentials: 'include',
  })
  if (!res.ok) {
    const error = await res.json().catch(() => ({ error: 'Request failed' }))
    throw new Error(error.error || 'Request failed')
  }
  return res.json()
}
```
  </action>
  <verify>
Create form submits successfully. Edit form loads existing data and updates correctly.
  </verify>
  <done>
Create course form at /admin/courses/new. Edit course form at /admin/courses/[id]. Both use React Hook Form + Zod.
  </done>
</task>

</tasks>

<verification>
1. Course list shows all courses in sortable table
2. "Add Course" button navigates to create form
3. Create form validates and submits to backend
4. Edit form loads existing data and updates
5. Delete action removes course from list
</verification>

<success_criteria>
- Admin can view all courses in DataTable
- Admin can create new course via form
- Admin can edit existing course
- Admin can delete course via action menu
- Forms validate with Zod schema matching backend
</success_criteria>

<output>
After completion, create `.planning/phases/08-admin-dashboard/08-04-SUMMARY.md`
</output>
